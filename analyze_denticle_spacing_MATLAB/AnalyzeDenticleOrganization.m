%{
CODE TO CALCULATE DENTICLE SPACING

Input: Results.txt file output from ImageJ Cell_Counter plugin
Each file should contain information from one row in a belt of an embryo
Data is sorted by x-coordinate value to get proper organization


Input files must be named in a way that the program can parse:

<ID #>_<stage>_<genotype>_b <belt#>r <row #>.txt
    <ID #> is a 4-digit identifier unique to each embryo
    ex. 0151_15_yw_b3r2.txt

        and
        0151_15_yw_****_b3r2.txt
        are both acceptable

    If several separate files are needed for the same embryo/belt/row combo, put that number BEFORE the b@r# data (e.g. ****b7r1.txt  and ****2b7r1.txt )

Cell Counter Plugin Output file data:
    Column 1 = Marker type,
            denticle = 1,
            cell edge = 2
    Column 2 = Slice (1 for all data in single plane snap or z-projected image)
    Column 3 = x-coordinate, should be in pixels
    Column 4 = y-coordinate, should be in pixels
    Column 5 = pixel intensity value (currently don't use this information)


%}

%% Set-up
% maindirectory=uigetdir; % directory containing these scripts
% inputdirectory_raw=uigetdir; % directory containing these scripts

clear all; clc; close all;

maindirectory = './analyze_denticle_spacing_MATLAB';
inputdirectory_raw = './analyze_denticle_spacing_MATLAB/input_text_files';

cd(maindirectory);

% DEFINING VARIABLES

% set up global variables
global totalgenotypestoanalyze

% type markers are from the 'dataImport' array, in the dataImport.tedxtdata (the column headings generated by the CellCounter plugin).
% This is a way to identify which direction you should sort along the points (which way the image is oriented)


denticlemarker = 1;                     % type 1 marker = denticle
edgemarker = 2;             % type 2 marker = cell edge
beltdir = 3;                % denticle rows run along x(col3) or y(col4) direction


allthegenotypes = {'yw',  'row1WT',  'ms3k81',  'cycEp35', 'SpastinOE',   '1stInstar', 'L1',  'PatroninTRiP'};  % string list of genotype names
allthescales =    [11.517, 11.517,   11.517, 11.517, 11.517, 11.517,  8.318, 11.517];  % in px/Âµm





% MAIN USER INPUTS 
% Import & calculations, or just calculations
whattodo_main = input('What do you want to do? \n 0 = everything: import raw data from text files, make csv files, run calculations. \n 1 = just calculations: Use existing csv files to run calculations  \n default is 1/calculations only:       \n');
if isempty(whattodo_main),
    whattodo_main = 1;
elseif whattodo_main >= 2,
    error('That isnt a valid value for assignment, try again')
end 

disp('')

% Types of calculations
calctodo = input('Which calculations? 0=[statistics only]  1=[pool]  2=[pool+indiv]  3=[indiv] \n default is 2:     \n');
if isempty(calctodo)
    calctodo = 2;
elseif calctodo >= 4
    error('That isnt a valid value for assignment, try again')
end

if calctodo == 0,
    disp('statistics only')
elseif calctodo == 1,
    disp('combined only')
elseif calctodo == 2,
    disp('combined and individual for averages')
elseif calctodo == 3,
    disp('individuals only')
end

disp('')

% Constants (to get rid of eventually)
makefig_internal = 0;
makefig_fxn = 0;


% Genotypes to analyze
disp('Which genotypes do you want to analyze?')
disp('Default is')
allthegenotypes'


getgenotypes = input('Input genotypes to analyze?    \n 0 = default    \n 1 = input specifics:      \n');
if isempty(getgenotypes),
    getgenotypes = 0;
elseif getgenotypes >= 2, 
    error('Not valid, try again')
end 

if getgenotypes == 0, 
    genotypes = allthegenotypes;
    scales = allthescales;
elseif getgenotypes == 1, 
    numbergenotypestoget = input('How many genotypes to analyze?:   ');
    for gntplistnumber = 1:numbergenotypestoget, 
        gntplistnumber
        genotypes{gntplistnumber} = input('genotype:   ','s');
        scales(gntplistnumber) = input('scale:  ');
    end
end


disp('')





% Check that things are okay with the genotypes entered 
% Check that all genotypes have input data files
for k = 1:length(genotypes), 
    currentgenotypeID = genotypes{k};

    filepattern = sprintf('*%1$s*.%2$s',currentgenotypeID,'txt');
    testdir = dir([inputdirectory_raw, filesep, filepattern]);

    % testdir = dir(sprintf('*%1$s*.%2$s',currentgenotypeID,'txt'));
    if isempty(testdir) == 1,
        error('there are no files with %s in the filename',currentgenotypeID)
%     else
%         disp(currentgenotypeID)
%         disp('Filenames look good')
    end
end
disp('Filenames look good')



disp('')
disp('')
disp('okay. running through each genotype.')
disp(' ')
disp(' ')




formatOut = 'yyyy.mm.dd_HHMM';
timerun = datestr(now,formatOut);
disp('date & time = ')
disp(timerun)


outputdirectory = [maindirectory, filesep, 'Output_',timerun]
mkdir(outputdirectory)


if whattodo_main == 1, 
    disp('select directory where Stack.csv files are located')
    inputdata_recalculate = uigetdir;
end 


% Run through each genotype individually 
cd(outputdirectory)
for numbofgenotypes = 1:length(genotypes),
%    load('SetupData.mat');
    totalgenotypestoanalyze = length(genotypes);
    genotype = genotypes{numbofgenotypes};
    scale = scales(numbofgenotypes);
    gtDir = genotype;
    
    disp(' ')
    disp(' ')
    disp(genotype)
    disp(' ')
    
    sc = ['scale set as ',num2str(scale), ' px/um'];
    disp(sc)
    

%     genotime = genotype;
    % genotime = strcat(genotype,'_',timerun);



    % JUST CALCULATIONS
    if whattodo_main == 1, 
        disp('Calculations on denticle spacing data')

        DataDivider(inputdata_recalculate, calctodo, genotype, totalgenotypestoanalyze)




    % IMPORT DATA AND RUN CALCULATIONS
    elseif whattodo_main == 0, 
        disp('Code to calculate denticle spacing')

        cd(outputdirectory);

        %%  GET DATA
        for dentrow = 0:6,
            
            dirquerystr = sprintf('*%1$s*%2$c%3$i.%4$s',genotype,'r',dentrow,'txt');
            CellCounterData = dir([inputdirectory_raw, filesep, dirquerystr]);
                    
            if dentrow == 6,        % Combine rows 6 and 7, since they're essentially the same (easier to save a row 7 than 2bxr6)
                dirquerystr2 = sprintf('*%1$s*%2$c%3$i.%4$s',genotype,'r',7,'txt');
                CellCounterData2 = dir([inputdirectory_raw, filesep, dirquerystr2]);
                CellCounterData = cat(1,CellCounterData,CellCounterData2);
            end
            
            numfiles = length(CellCounterData);         % Get the number of .txt files found in the above
            
            % Calculate spacing data, cell size data
            % Get each data file individually in sequence, import the data portion
            % so you can run calculations on it
            for k = 1:numfiles,
                fileToRead = CellCounterData(k).name;
                dataImport = importdata(fileToRead);
                data = dataImport.data;
                
                ntotal = size(data,1);      % nt = the number of data points total (denticles and cell edges)
                dist = zeros;               %reset matrix (i hope)
                
                % Get name of file to add into matrices to allow for separation by embryo
                [filePath,fileName,fileExt] = fileparts(fileToRead);
                embryoID = 100*str2double(fileName(1:4))+str2double(fileName(6:7));
                % 1:4 is the embryoID#, 6:7 is the stage
                % Convert first 4 characters (ID number) from a string to a number so it can go into the established matrices without trouble
                % Changing from fileName(6:7) to just (7)
                % to eliminate a problem with scientific
                % notation in the csv file at the end...
                
                if isnan(embryoID) == 1,
                    error('something is wrong with your input text file names')
                end
                
                beltID = str2double(fileName((length(fileName))-2));
                
                % SORT DATA
                % Sort positions (all objects) by order along row; points can be picked in any order in the CellCounter plugin
                data = sortrows(data,beltdir);
                
                % List of just denticles
                d_ind = find(data(:,1) == denticlemarker);
                num_dent = length(d_ind);
                denticles = data(d_ind,:);
                
                % List of just edges
                e_ind = find(data(:,1) == edgemarker);
                num_edges = length(e_ind);
                edges = data(e_ind,:);
                
                
                % Separate out on a cell basis
                ibccounter = 1;          % Counter for interbycell matrix
                aecounter = 1;
                
                bycell = zeros(1,20);       % Make empty matrix of a consistent column number
                intrabycell = zeros(1,7);
                cellnumber = 0;
                
                for i = 1:num_edges-1,
                    cellnumber = cellnumber + 1;                
                    a = 1;                          % Counter for inclDent matrix; resets with each new cell edge pair
                    inclDent = zeros(20,5);         % Preallocate & reset for each iteration
                    adjacentDent = zeros(2,5);      % Preallocate & reset for each iteration
                    
                    % Get edges of current cell
                    ledge = edges(i,:);
                    redge = edges(i+1,:);
                    
                    % Get X values from all the denticles in this row
                    onlydentvals = denticles(:,beltdir);
                    
                    
                    % Look at all the denticles in the dataset and determine which are contained within the cell boundaries
                    for j = 1:size(onlydentvals,1),
                        
                        % Get X coordinate for the denticle
                        dentinq = onlydentvals(j);
                        
                        % Compare the X coordinates of denticle 'j' to the left and
                        % right edges. If the denticle is contained within a cell,
                        % write all its associated data into the 'a'th row of
                        % inclDent
                        if (dentinq > ledge(:,beltdir)) && (dentinq < redge(:,beltdir)),
                            inclDent(a,1:5) = denticles(j,1:5);
                            a = a + 1;
                            
                            % If the denticle is not the first or the last in the dataset, get data on the denticles on either side
                            if (j ~= 1) && (j ~= size(onlydentvals,1)),
                                dentbefore = onlydentvals(j-1);
                                dentafter = onlydentvals(j+1);
                                
                                % If the neighboring denticle(s) are NOT in the same cell, write them into the appropriate matrix
                                if onlydentvals(j-1) < ledge(:,beltdir),
                                    adjacentDent(1,1:5) = denticles(j-1,1:5);
                                end
                                
                                if onlydentvals(j+1) > redge(:,beltdir),
                                    adjacentDent(2,1:5) = denticles(j+1,1:5);
                                end
                                
                                % Otherwise if the denticle is the first or the last in the set, write the adjacent coordinates as zeros
                            elseif j == 1,
                                adjacentDent(1,1:5) = [0 0 0 0 0];
                                
                            elseif j == size(onlydentvals,1),
                                adjacentDent(2,1:5) = [0 0 0 0 0];
                            end
                        end
                    end
                    
                    
                    
                    if max(max(inclDent)) == 0,
                        cellnumber = cellnumber-1;
                        %{
                            This gets the maximum value in the entire inclDent
                            matrix; if this is an empty matrix, the max will be 0.
                            Stop if there are no denticles assigned between the two
                            edges (indicates a break ex. at the midline; don't need
                            to save as multiple files any more)
                        %}
                    else
                        inclDent = inclDent(any(inclDent,2),:);         % This eliminates zero rows in the 'inclDent' matrix so when it is counting the number of dent/cell you only count nonzero rows
                        
                        dentincell = size(inclDent,1);
                        
                        % Embryo identification data
                        bycell(i,1) = embryoID;
                        bycell(i,2) = dentrow;
                        bycell(i,3) = beltID;
                        
                        % basic data about the cell
                        bycell(i,4) = cellnumber;                                   % Cell number within the row
                        bycell(i,5) = dentincell;                                   % number of denticles in the current cell
                        bycell(i,6) = (norm((redge(3:4))-(ledge(3:4))))/scale;      % DV length
                        
                        % Denticle to edge distances
                        bycell(i,7) = norm((inclDent(1,(3:4)))-(ledge(3:4)))/scale;
                        bycell(i,8) = norm((redge(3:4))-(inclDent(dentincell,3:4)))/scale;
                        
                        % Adjacent/inter distance values
                        if (adjacentDent(1,3) ~= 0) && (adjacentDent(1,4) ~= 0),        % If the X and Y coordinate values are non-zero
                            bycell(i,9) = norm((adjacentDent(1,3:4))-(inclDent(1,3:4)))/scale;      % Calculate inter distance using the denticle pair on the left
                        else bycell(i,9) = 0;
                        end
                        
                        if (adjacentDent(2,3) ~= 0) && (adjacentDent(2,4) ~= 0),
                            bycell(i,10) = norm((adjacentDent(2,3:4))-(inclDent(dentincell,3:4)))/scale; % Calculate inter distances using the denticle pair on the right
                        else bycell(i,10) = 0;
                        end
                        
                        
                        % Same cell/intra distance values
                        if dentincell > 1,
                            c = 11;
                            for j = 1:(dentincell - 1),
                                bycell(i,c) = norm(inclDent(j,3:4)-inclDent(j+1,3:4))/scale;
                                c = c+1;
                            end
                        end
                        
                        
                        % Write intra data into a separate matrix with one cell per
                        % row, type 1
                        if dentincell == 1,
                            intrabycell(ibccounter,1:7) = 0;
                        elseif dentincell >1,
                            for j = 1:(dentincell-1),
                                intrabycell(ibccounter,1) = embryoID;
                                intrabycell(ibccounter,2) = dentrow;
                                intrabycell(ibccounter,3) = beltID;
                                intrabycell(ibccounter,4) = i; % Cell/iteration number
                                intrabycell(ibccounter,5) = dentincell;  % # of denticles in cell
                                intrabycell(ibccounter,6) = (norm((redge(3:4))-(ledge(3:4))))/scale; % DV length of cell
                                intrabycell(ibccounter,7) = norm(inclDent(j,3:4)-inclDent(j+1,3:4))/scale; % Intra distance
                                ibccounter = ibccounter+1;
                            end
                        end
                        
                        % Write intra data into a separate matrix, type 2
                        % (IntraInterSpread.m)
                        if dentincell == 1,
                            aebydic(aecounter,1) = embryoID;
                            aebydic(aecounter,3) = dentrow;
                            aebydic(aecounter,4) = beltID;
                            aebydic(aecounter,5) = dentincell;
                            
                            aebydic(aecounter,7) = norm((inclDent(1,(3:4)))-(ledge(3:4)))/scale;
                        aebydic(aecounter,8) = norm((redge(3:4))-(inclDent(1,3:4)))/scale;
                        
                        elseif dentincell >1,
                            for j = 1:dentincell,
                                aebydic(aecounter,1) = embryoID; %#ok<*SAGROW>
                                aebydic(aecounter,3)= dentrow;
                                aebydic(aecounter,4) = beltID;
                                aebydic(aecounter,5) = dentincell;
                                if j == 1,
                                    aebydic(aecounter,7) = norm((inclDent(1,(3:4)))-(ledge(3:4)))/scale;
                                    aebydic(aecounter,6) = norm(inclDent(j,3:4)-inclDent(j+1,3:4))/scale; % Intra distance
                                elseif (j ~= dentincell) && (j ~=1),
                                    aebydic(aecounter,6) = norm(inclDent(j,3:4)-inclDent(j+1,3:4))/scale; % Intra distance
                                elseif j == dentincell
                                    aebydic(aecounter,8) = norm((redge(3:4))-(inclDent(j,3:4)))/scale;
                                end

                                aecounter = aecounter+1;
                            end
                        end
                    
                    aebydic = aebydic(any(aebydic,2),:);
                    
                    dlmwrite(SpiffyName('csv', 'IntraDV', genotype),aebydic,'-append');
                    
                end
            end
            
            
            % OUTPUT FILES
            
            % save('Results.mat', 'bycell', 'intrabycell');
            
            cbcfilename = (SpiffyName('csv','cellbyCellStack', genotype));
            ibcfilename = (SpiffyName('csv','intrabyCellStack', genotype));
            % these cannot be changed to include the timerun in the filename or
            % everything else breaks!
            
            dlmwrite(cbcfilename,bycell,'-append');
            dlmwrite(ibcfilename,intrabycell,'-append');
            % Add the new data from this row to the end of the existing matrix
            
            
            
        end
        disp('done with row:')
        disp(dentrow)
            
            
        end

        disp('Done with import and quantification')

        %% Reformat data (column headers, reorder)

        % Cellbycell
        % embryoID,row,belt,cell,dentincell,Dvlen,dentEdgeL,dentEdgeR,AdjL,AdjR,Intra1-2,Intra2-3,Intra3-4,Intra4-5,Intra5-6,Intra6-7,Intra7-8,Intra8-9

        cbctitles_raw = {'embryoID', 'row', 'belt', 'cell', 'dentincell', 'Dvlen', 'dentEdgeL', 'dentEdgeR', 'AdjL', ...
            'AdjR', 'Intra1-2', 'Intra2-3','Intra3-4','Intra4-5', 'Intra5-6', 'Intra6-7', 'Intra7-8', 'Intra8-9',...
            'Intra9-10', 'Intra10-11','Intra11-12','Intra12-13', 'Intra13-14', 'Intra14-15', 'Intra15-16', 'Intra16-17','Intra17-18', 'Intra18-19',...
            'Intra19-20','Intra20-21','Intra21-22','Intra22-23', 'Intra23-24', 'Intra24-25', 'Intra25-26', 'Intra26-27','Intra27-28', 'Intra28-29','Intra29-30',...
            '-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-'};
        cbctemp = dlmread(cbcfilename);
        cbctitles = cbctitles_raw(1:(size(cbctemp,2)));
        AddHeaders((SpiffyName('csv','CellbyCell', genotype)), cbctitles, cbctemp);

        % Intrabycell
        ibctitles = {'embryoID', 'row', 'belt', 'cell', 'dentincell', 'Dvlen', 'Intra','-','-','-','-'};
        ibctemp = dlmread(ibcfilename);
        AddHeaders(( SpiffyName('csv','IntrabyCell', genotype)), ibctitles, ibctemp);

        % Rearrange data to look like it would across each cell
        % Uses cbctemp data

        maxintra = max(cbctemp(:,5)) -1;    % Max number of intra values that need to be accomodated is one fewer than the total number of denticles in the final output data

        % Titles set-up and joining routine
        cotitles_part1 = {'embryoID', 'row', 'belt', 'cell', 'dentincell', 'Dvlen', 'AdjL', 'dentEdgeL'};
        cotitles_part2 = {'-', 'Intra1-2', 'Intra2-3','Intra3-4','Intra4-5', 'Intra5-6', 'Intra6-7', 'Intra7-8', 'Intra8-9',...
            'Intra9-10', 'Intra10-11','Intra11-12','Intra12-13', 'Intra13-14', 'Intra14-15', 'Intra15-16', 'Intra16-17','Intra17-18', 'Intra18-19',...
            'Intra19-20','Intra20-21','Intra21-22','Intra22-23', 'Intra23-24', 'Intra24-25', 'Intra25-26', 'Intra26-27','Intra27-28', 'Intra28-29','Intra29-30'};
        % empty '-' at position 1 in cotitles2 is a contrivance so you don't have to subtract 1 from maxdent; the effect is the same as (1:(maxdent-1))
        cotitles_part3 = {'dentEdgeR', 'AdjR'};
        cotitles_part4 = {'-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-'};

        cotitles = [cotitles_part1,cotitles_part2(2:maxintra+1),cotitles_part3];

        % Add pad headers ('-') if necessary - ie if there are blank rows
        % at the end of the cbctemp matrix
        if size(cotitles,2) < size(cbctemp,2)
            delta = size(cbctemp,2) - size(cotitles,2);
            cotitles = [cotitles,cotitles_part4(1:delta)];
        end

        cellorder = [cbctemp(:,1:6), cbctemp(:,9), cbctemp(:,7),cbctemp(:,11:(maxintra +10)), cbctemp(:,8), cbctemp(:,10)];
        %  Intra values placement: 11(the start in cbctemp) : (maxdent -1 (one less intra value than there are denticles) +10 (number of positions before the intra goes in))
        dlmwrite((SpiffyName('csv','cellOrderStack', genotype)),cellorder);
        AddHeaders((SpiffyName('csv','CellOrder', genotype)), cotitles, cellorder)

        % Rearrange Intra v dv
        aetemp = dlmread(SpiffyName('csv','IntraDV', genotype));
        aetemp = sortrows(aetemp,5);

        dlmwrite(SpiffyName('csv','IntraDVsort', genotype),aetemp);
        disp('Done with reformatting')



        DataDivider(outputdirectory, calctodo, genotype, totalgenotypestoanalyze)

    end 

end 

if calctodo ~= 0 && length(genotypes) > 1, 
    RearrangeThings(genotypes)
end

disp(' ')
disp('done calculating. still scheming, though')